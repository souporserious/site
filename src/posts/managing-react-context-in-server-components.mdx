---
title: Managing React Context in Server Components
date: 2022-10-30
image: ../images/context.png
summary: React Server Components introduce a new way to build React applications. This post will look at how to manage Context in this latest paradigm.

tags:
  - react
  - context
  - server
  - components
  - nextjs
---

The first public version of React Server Components recently made its debut at [NextJS Conf 2022](https://www.youtube.com/watch?v=NiknNI_0J48). This new concept dramatically simplifies how data is fetched in React components and trims them down to only include the static code collected on the server:

```tsx
export default async function App() {
  const response = await fetch('https://pokeapi.co/api/v2/pokemon')
  const allPokemon = (await response.json()).results

  return (
    <ul>
      {allPokemon.map((pokemon) => (
        <li key={pokemon.name}>{pokemon.name}</li>
      ))}
    </ul>
  )
}
```

While most everything you're used to when developing React applications is the same, Server Components have a few new constraints. Specifically, we can no longer rely on interactivity; this includes the standard React state hooks you're used to, like `useState`, `useContext`, and event handlers like `onClick`.

When you need to introduce interactivity, you do so by marking the top of the file with a `use client` directive. This directive informs the bundler you're using that the component requires additional JavaScript to run beyond the server:

```tsx
'use client'
import { useState } from 'react'

export function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <button onClick={() => setCount((count) => count - 1)}>Decrease</button>
      <span>{count}</span>
      <button onClick={() => setCount((count) => count + 1)}>Increase</button>
    </div>
  )
}
```

See the list in the [NextJS docs](https://beta.nextjs.org/docs/rendering/server-and-client-components#when-to-use-server-vs-client-components) for a detailed guide on when to use Server vs. Client components.

## Managing Context

With these new APIs explained, let's look at how we can weave React Context throughout our application. We'll use a simple NextJS 13 application that defines a `SystemProvider`, allowing users of our library to specify a preferred font size. Follow along at the Codesandbox below:

[![Edit Managing React Context in Server Components](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/p/sandbox/managing-context-in-server-components-bg5ktc?file=%2Fapp%2Flayout.tsx&selection=%5B%7B%22endColumn%22%3A18%2C%22endLineNumber%22%3A7%2C%22startColumn%22%3A18%2C%22startLineNumber%22%3A7%7D%5D)

To keep this post focused, we won't get into the details of how the new layout architecture works in NextJS. Please refer to the [documentation](https://beta.nextjs.org/docs/getting-started) for a more in-depth overview.

## Leaning Into Composition

Server Components will push developers to use useful JSX features that have always been available, like the `children` prop or any prop that returns JSX elements. This feature is excellent because props that return JSX allow consumers of your components to compose building blocks together rather than you having to make too many assumptions about how your components work together.

In our app directory, we'll use the standard layout that NextJS ships with when using the automatic installation:

```tsx filename=layout.tsx
import './globals.css'

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </head>
      <body>{children}</body>
    </html>
  )
}
```

If we try to import `React.createContext` here, we will get an error; remember, Server Components will only return stringified content and cannot contain additional JavaScript. Thankfully, the NextJS team has helped us here and will throw an eslint error when trying to do this. Now is where we will create our first Client Component. Let's make a new `SystemProvider` file to house our Context that allows users to control the font size:

```tsx filename=components/SystemProvider.tsx
'use client'
import { createContext, useContext } from 'react'

const SystemContext = createContext<{
  fontSize: 'small' | 'medium' | 'large'
}>({
  fontSize: 'medium',
})

export function useSystem() {
  return useContext(SystemContext)
}

export function SystemProvider({
  children,
  fontSize,
}: {
  children: React.ReactNode
  fontSize: 'small' | 'medium' | 'large'
}) {
  return (
    <SystemContext.Provider value={{ fontSize }}>
      {children}
    </SystemContext.Provider>
  )
}
```

Next, we'll add a `Text` component that consumes this Context. Again, this will be a Client Component because of the reliance on `useContext`. As a good rule for now, anytime you need a hook, you will most likely need to mark that component utilizing that hook as a Client Component:

```tsx filename=components/Text.tsx
'use client'
import { useSystem } from './SystemProvider'

const fontSizes = {
  small: '0.8rem',
  medium: '1rem',
  large: '1.2rem',
}

export function Text({
  href,
  children,
  ...restProps
}: {
  href?: string
  children: React.ReactNode
} & React.HTMLAttributes<HTMLElement>) {
  const Element = href ? 'a' : 'span'
  const { fontSize } = useSystem()

  return (
    <Element
      href={href}
      style={{ fontSize: fontSizes[fontSize] }}
      {...restProps}
    >
      {children}
    </Element>
  )
}
```

Now, we can use both components throughout our application and interweave them into our Server Components. We'll add the `SystemProvider` to our top-level layout:

```tsx filename=layout.tsx
export default function RootLayout({ children }) {
   return (
    ...
      <body>
        <SystemProvider fontSize="large">{children}</SystemProvider>
      </body>
    ...
  )
}
```

We explicitly set a static font size that showcases the power of Server and Client components. We can pass serializable data between these components while retaining the benefits of only loading what's needed. In a real-world application or as an exercise for the reader, you will likely have another Client Component that offers a toggle that allows updating the Provider value using your flavor of state management.

## Conclusion

This was a simple look at the constraints of using Context in the new world of Server Components. Remember, anytime you need to add functionality that will update beyond static content, you can start to introduce Client Components. A nice benefit of this new constraint is it draws a clear boundary of what should and should not live in Context. In most cases, Context is most beneficial for scenarios like user preferences, but this also begs the question of where that state should live. It could all move to the server now, depending on what you are building.
